// File ID: lab03b.cpp
// Title: Interactive program for calculating line properties and DDA output
// Author: (your name)

#define FREEGLUT_STATIC
#include <GL/freeglut.h>
#include <cmath>
#include <iostream>
#include <vector>
#include <iomanip>
using namespace std;

// For OpenGL line endpoints: [Ax, Ay, Bx, By, Cx, Cy, Dx, Dy]
float a[8];

void DDA_line(float x0, float y0, float x1, float y1, vector<pair<int, int>>& pixels) {
    float dx = x1 - x0;
    float dy = y1 - y0;
    int steps = (int)(fabs(dx) > fabs(dy) ? fabs(dx) : fabs(dy));
    float x_inc = dx / steps;
    float y_inc = dy / steps;
    float x = x0, y = y0;
    for (int i = 0; i <= steps; ++i) {
        pixels.push_back({ (int)round(x), (int)round(y) });
        x += x_inc;
        y += y_inc;
    }
}

void print_DDA_lines() {
    cout << "DDA Line Algorithm Pixel Positions:\n";

    // Line 1: (-2, 3) to (10, 8)
    vector<pair<int, int>> line1_pixels;
    DDA_line(-2, 3, 10, 8, line1_pixels);
    cout << "Line 1 from (-2,3) to (10,8):\n";
    for (auto& p : line1_pixels) {
        cout << "(" << p.first << "," << p.second << ") ";
    }
    cout << "\n\n";

    // Line 2: (-2, 3) to (-22, 33)
    vector<pair<int, int>> line2_pixels;
    DDA_line(-2, 3, -22, 33, line2_pixels);
    cout << "Line 2 from (-2,3) to (-22,33):\n";
    for (auto& p : line2_pixels) {
        cout << "(" << p.first << "," << p.second << ") ";
    }
    cout << "\n\n";
}

void explain_circle_symmetry() {
    cout << "Circle Algorithm Symmetry Explanation:\n";
    cout << "The symmetry of a circle allows us to calculate the points for just one octant (1/8th) of the circle.\n";
    cout << "Using the center and radius, the other points can be generated by reflecting across the axes and diagonals.\n";
    cout << "This reduces computation and improves efficiency by a factor of 8.\n\n";
}

// Calculate distance between two points
float line_length(float x0, float y0, float x1, float y1) {
    return sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
}

// Calculate gradient (slope)
float line_gradient(float x0, float y0, float x1, float y1) {
    if (fabs(x1 - x0) < 1e-7) // avoid division by zero
        return INFINITY;
    return (y1 - y0) / (x1 - x0);
}

// Check for parallel or perpendicular lines
void check_lines(float grad1, float grad2) {
    if (grad1 == grad2)
        cout << "Lines are parallel.\n";
    else if ((grad1 == INFINITY && grad2 == 0) || (grad2 == INFINITY && grad1 == 0) || fabs(grad1 * grad2 + 1) < 1e-5)
        cout << "Lines are perpendicular.\n";
    else
        cout << "Lines are neither parallel nor perpendicular.\n";
}

void draw_points_and_lines() {
    // Draw lines AB and CD
    glColor3f(1, 0, 0); // red lines
    glBegin(GL_LINES);
    glVertex2f(a[0], a[1]);
    glVertex2f(a[2], a[3]);
    glVertex2f(a[4], a[5]);
    glVertex2f(a[6], a[7]);
    glEnd();

    // Draw points A, B, C, D
    glPointSize(6.0f);
    glColor3f(0, 0, 1); // blue points
    glBegin(GL_POINTS);
    glVertex2f(a[0], a[1]);
    glVertex2f(a[2], a[3]);
    glVertex2f(a[4], a[5]);
    glVertex2f(a[6], a[7]);
    glEnd();
}

void to_OpenGL() {
    glClear(GL_COLOR_BUFFER_BIT);
    draw_points_and_lines();
    glFlush();
}

void init() {
    // Optionally, initialize sample coordinates
    // A(-2,3), B(10,8), C(-2,3), D(-22,33)
    a[0] = -2; a[1] = 3;
    a[2] = 10; a[3] = 8;
    a[4] = -2; a[5] = 3;
    a[6] = -22; a[7] = 33;
}

int main(int argc, char** argv)
{
    // 1. DDA algorithm
    print_DDA_lines();

    // 2. Circle symmetry explanation
    explain_circle_symmetry();

    // 3. Input for OpenGL part
    cout << fixed << setprecision(2);
    cout << "Enter coordinates for A (x y): "; cin >> a[0] >> a[1];
    cout << "Enter coordinates for B (x y): "; cin >> a[2] >> a[3];
    cout << "Enter coordinates for C (x y): "; cin >> a[4] >> a[5];
    cout << "Enter coordinates for D (x y): "; cin >> a[6] >> a[7];

    // (b) Lengths
    float lenAB = line_length(a[0], a[1], a[2], a[3]);
    float lenCD = line_length(a[4], a[5], a[6], a[7]);
    cout << "Length of AB: " << lenAB << endl;
    cout << "Length of CD: " << lenCD << endl;

    // (c) Gradients
    float gradAB = line_gradient(a[0], a[1], a[2], a[3]);
    float gradCD = line_gradient(a[4], a[5], a[6], a[7]);
    cout << "Gradient of AB: ";
    if (gradAB == INFINITY)
        cout << "infinity (vertical line)" << endl;
    else
        cout << gradAB << endl;
    cout << "Gradient of CD: ";
    if (gradCD == INFINITY)
        cout << "infinity (vertical line)" << endl;
    else
        cout << gradCD << endl;

    // (d) Check perpendicular or parallel
    check_lines(gradAB, gradCD);

    // (a,e) Draw in OpenGL
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(600, 600);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Lab03b - Line Properties and Drawing");
    glClearColor(1, 1, 1, 1);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-100, 100, -100, 100);
    glutDisplayFunc(to_OpenGL);
    glutMainLoop();

    return 0;
}